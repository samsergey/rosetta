<<<<<<< HEAD
=======
{-# language FlexibleContexts #-}
>>>>>>> 231348938c4036a6d68d0d625c9b3c476363cc15
import Data.List
import Data.Map ((!))
import qualified Data.Map as M
import Control.Monad (replicateM)
import Control.Monad.State
<<<<<<< HEAD
import qualified Data.Array as A

=======
import Data.Array (Array, (//))
import qualified Data.Array as A
 
>>>>>>> 231348938c4036a6d68d0d625c9b3c476363cc15
-- represents a permutation in a cycle notation
-- cycleForm [1,4,3,2,0]  ==>  [[1,4,0],[3,2]]
cycleForm :: [Int] -> [[Int]]
cycleForm p = unfoldr getCycle $ M.fromList $ zip [0..] p
  where
    getCycle p
      | M.null p = Nothing
      | otherwise = 
          let Just ((x,y), m) = M.minViewWithKey p
              c = if x /= y
                  then takeWhile (/= x) $ iterate (m !) y
                  else []
          in Just (c ++ [x], foldr M.delete m c)
<<<<<<< HEAD

-- the set of Lyndon words generated by inverse Burrows—Wheeler transform 
lyndonWords :: Ord a => Int -> [a] -> [[a]]
lyndonWords k s = map (ref !!) <$> cycleForm perm
  where
    ref = concat $ replicate (length s ^ (k - 1)) s
    perm = s >>= (`elemIndices` ref)

-- returns the de Bruijn sequence of order k for an alphabeth s
deBruijn :: Ord a => Int -> [a] -> [a]
deBruijn k s =
  let lw = concat $ lyndonWords k s
  in lw ++ take (k-1) lw


deBruijnA :: Int -> [Int] -> ((),(A.Array Int Int, [Int])) 
deBruijnA k s = go 1 1 `runState` (a, seq)
  where
    n = length s
    a = A.listArray (0,k*n) $ repeat 0
    seq = []
    go :: Int -> Int -> State (A.Array Int Int, [Int]) ()
    go t p
      | t > n && n `mod` p == 0 =
          modify $ \(a, s) -> (a, s ++ [ a A.! k | k <- [2..p+1]])
      | otherwise = do
          modify $ \(a, s) -> (a A.// [(t+1, a A.! (t-p+1))], s)
          go (t+1) p
          forM_ [a A.! (t-p+1) + 1..k-1] $
            \j -> do modify $ \(a, s) -> (a A.// [(t+1, j)], s)
                     go (t+1) t

main = do
  let symbols = ['0'..'9']
  let db = deBruijn 4 symbols
  putStrLn $ "The length of de Bruijn sequence: " ++ show (length db)
  putStrLn $ "The first 130 symbols are:\n" ++ show (take 130 db)
  putStrLn $ "The last 130 symbols are:\n" ++ show (drop (length db - 130) db)

  let words = replicateM 4 symbols
  let validate db  = filter (not . (`isInfixOf` db)) words
  putStrLn $ "Words not in the sequence: " ++ unwords (validate db)

  let db' = a ++ ('.': tail b) where (a,b) = splitAt 4444 db
  putStrLn $ "Words not in the corrupted sequence: " ++ unwords (validate db')    
    
    
=======
 
-- the set of Lyndon words generated by inverse Burrows—Wheeler transform 
lyndonWords :: Ord a => [a] -> Int -> [[a]]
lyndonWords s n = map (ref !!) <$> cycleForm perm
  where
    ref = concat $ replicate (length s ^ (n - 1)) s
    perm = s >>= (`elemIndices` ref)
 
-- returns the de Bruijn sequence of order k for an alphabeth s
deBruijn :: Ord a => [a] -> Int -> [a]
deBruijn s n =
  let lw = concat $ lyndonWords s n
  in lw ++ take (n-1) lw


deBruijnA :: [a] -> Int -> [a]
deBruijnA s n =
  let
    k = length s
    
    db :: Int -> Int -> State (Array Int Int) [Int]
    db t p =
      if t > n
      then 
        if n `mod` p == 0
        then get >>= \a -> return [ a A.! k | k <- [1 .. p]]
        else return []
      else do
        a <- get
        x <- setArray t (a A.! (t-p)) >> db (t+1) p
        a <- get
        y <- sequence [ setArray t j >> db (t+1) t
                      | j <- [a A.! (t-p) + 1 .. k - 1] ]
        return $ x ++ concat y
        
    setArray i x = modify (// [(i, x)])
    
    seqn = db 1 1 `evalState` A.listArray (0, k*n-1) (repeat 0)
    
  in [ s !! i | i <- seqn ++ take (n-1) seqn ]
  
main = do
  let symbols = ['0'..'9']
  let db = deBruijnA symbols 4
  putStrLn $ "The length of de Bruijn sequence: " ++ show (length db)
  putStrLn $ "The first 130 symbols are:\n" ++ show (take 130 db)
  putStrLn $ "The last 130 symbols are:\n" ++ show (drop (length db - 130) db)
 
  let words = replicateM 4 symbols
  let validate db  = filter (not . (`isInfixOf` db)) words
  putStrLn $ "Words not in the sequence: " ++ unwords (validate db)
 
  let db' = a ++ ('.': tail b) where (a,b) = splitAt 4444 db
  putStrLn $ "Words not in the corrupted sequence: " ++ unwords (validate db')    
>>>>>>> 231348938c4036a6d68d0d625c9b3c476363cc15
