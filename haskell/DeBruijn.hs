import Data.List
import Data.Map ((!))
import qualified Data.Map as M
import Control.Monad (replicateM)
import Control.Monad.State
import qualified Data.Array as A

-- represents a permutation in a cycle notation
-- cycleForm [1,4,3,2,0]  ==>  [[1,4,0],[3,2]]
cycleForm :: [Int] -> [[Int]]
cycleForm p = unfoldr getCycle $ M.fromList $ zip [0..] p
  where
    getCycle p
      | M.null p = Nothing
      | otherwise = 
          let Just ((x,y), m) = M.minViewWithKey p
              c = if x /= y
                  then takeWhile (/= x) $ iterate (m !) y
                  else []
          in Just (c ++ [x], foldr M.delete m c)

-- the set of Lyndon words generated by inverse Burrowsâ€”Wheeler transform 
lyndonWords :: Ord a => Int -> [a] -> [[a]]
lyndonWords k s = map (ref !!) <$> cycleForm perm
  where
    ref = concat $ replicate (length s ^ (k - 1)) s
    perm = s >>= (`elemIndices` ref)

-- returns the de Bruijn sequence of order k for an alphabeth s
deBruijn :: Ord a => Int -> [a] -> [a]
deBruijn k s =
  let lw = concat $ lyndonWords k s
  in lw ++ take (k-1) lw


deBruijnA :: Int -> [Int] -> ((),(A.Array Int Int, [Int])) 
deBruijnA k s = go 1 1 `runState` (a, seq)
  where
    n = length s
    a = A.listArray (0,k*n) $ repeat 0
    seq = []
    go :: Int -> Int -> State (A.Array Int Int, [Int]) ()
    go t p
      | t > n && n `mod` p == 0 =
          modify $ \(a, s) -> (a, s ++ [ a A.! k | k <- [2..p+1]])
      | otherwise = do
          modify $ \(a, s) -> (a A.// [(t+1, a A.! (t-p+1))], s)
          go (t+1) p
          forM_ [a A.! (t-p+1) + 1..k-1] $
            \j -> do modify $ \(a, s) -> (a A.// [(t+1, j)], s)
                     go (t+1) t

main = do
  let symbols = ['0'..'9']
  let db = deBruijn 4 symbols
  putStrLn $ "The length of de Bruijn sequence: " ++ show (length db)
  putStrLn $ "The first 130 symbols are:\n" ++ show (take 130 db)
  putStrLn $ "The last 130 symbols are:\n" ++ show (drop (length db - 130) db)

  let words = replicateM 4 symbols
  let validate db  = filter (not . (`isInfixOf` db)) words
  putStrLn $ "Words not in the sequence: " ++ unwords (validate db)

  let db' = a ++ ('.': tail b) where (a,b) = splitAt 4444 db
  putStrLn $ "Words not in the corrupted sequence: " ++ unwords (validate db')    
    
    
