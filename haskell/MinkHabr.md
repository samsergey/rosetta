# Про вопросительный знак и корекурсию

В этой заметке я хочу поделиться решением одной любопытной задачи с замечательного сайта-хрестоматии RosettaCode. При этом будет немного математики, язык Haskell, ленивые вычисления, бесконечные деревья, доказательства корректности программ и другие плюшки.

## Немного математики

Есть в теории чисел любопытная функция с не менее любопытными названием и обозначением: вопросительный знак Минковского (Fragenfunktion). С её помощью можно перенумеровать элементы расширения поля рациональных чисел квадратичными иррациональностями, то есть, корнями всех алгебраических уравнений второго порядка с рациональными коэффициентами. Не уверен, что большинство читателей впечатлит эта возможность, но функция такая есть и используется с 1904 года, когда её определил Герман Минковский в своём труде "Zur Geometrie der Zahlen" ("О теории чисел"), исследуя квадратичные иррациональности. Потом детальный анализ этой функции был представлен в работе Арно Денджоя в 1938 году, а много позже независимо от Минковского обратную ей функцию определил знаменитый Джон Конвей, исследователь монструозных групп, создатель игры "Жизнь" и стрелочной нотации для очень-очень-преочень больших чисел. Не знаю уж чем руководствовался Герман Минковский, выбирая обозначение для своей функции, но Джон Конвей тоже не нашёл ничего лучше чем обозначить свою функцию квадратом. Итак, сегодня речь пойдёт о двух функциях: $$?(x)$$ и обратной ей $$?^{-1}(x) \quiv \boxed{x}$$ (и как только до изобретения LaTeX-а математики убеждали издателей, что им нужны именно эти забавные символы?).

Вопросительный знак Минковского это монотонная вещественнозначная нечётная функция, заданная на всей числовой оси. В конечной форме она определяется довольно громоздко:

$$?(x) = 2\sum_{k=1}^{N}(-1)^{k+1}2^{-(a_1 + a_2 +  ... + a_k)},$$

где $$a_1, a_2, ...$$-- это целые числа, появляющиеся при разложении числа в цепную дробь: 

$$x = [a_0; a_1, a_2, a_3...] = a_0 + \frac{1}{a_1+\frac{1}{a_2 + \frac{1}{a_3 +...}}}$$

Суммирование степеней двойки означает, что она превращает представление числа в виде цепной дроби в её двоично-рациональное представление:

$$x = [a_0;a_1, a_2, a_3,a_4...] = a_0 + \overbrace{\underbrace{0.0...0}_{a_1}}^{нули}\overbrace{\underbrace{11..11}_{a_2}}^{единицы}\overbrace{\underbrace{0...0}_{a_3}}^{нули}\overbrace{\underbrace{11..11}_{a_4}}^{единицы}...$$

Например, число $$119/36$$ представляется в виде цепной дроби как $$[3;3,3,1,2]$$ функция Минковского преобразует его в такое двоично-рациональное число: $$3 + 0.00111011_{(2)}$$ (три нуля, три единицы, один ноль и две единицы). После интерпретации этого числа в  форме обычной дроби получим число $$3 + {59}/{256} = 827/256$$. То есть,

$$3 + {59}/{256} = 827/256$$

Ну, и зачем понадобилась эта "криптография"? Для того, чтобы разредить плотное множество рациональных чисел и поместить в него квадратичные иррациональности. Это и было целью исследования Германа Минковского. Все рациональные дроби имеют конечное представление в виде цепной дроби, а это значит, что функция все рациональные числа в двоично-рациональные, то есть, в дроби со знаменателем -- степенью двойки. А как можно получить дробь с иным знаменателем? В двоично-рациональном представлении всем числам со знаменателями, не степенями двойки соответствуют бесконечные периодические дроби. Например, 

Прообразом такого числа должно быть число с бесконечной, но периодической цепной дробью. А это именно то свойство, что отличает квадратичные иррациональные числа от прочих иррациональных. И все такие числа имеют форму , где числа и -- рациональные. Например для приведённого нами числа прообраз функции Минковского будет квадратичной иррациональностью:

Таким образом, функция Минковского помещает в "пространство" между прореженными рациональными числами все квадратичные иррациональности, причём она это делает очень аккуратно: монотонно, непрерывно и с сохранением порядка. Так что, хоть построение этой функции поначалу кажется искусственным, тем не менее, работает она  очень естественным образом. При этом она обладает рядом замечательных неочевидных симметрий, имеет фрактальный график и не сморя на непрерывность, имеет почти всюду нулевую производную (она равна нулю в рациональных аргументах и бесконечности -- в иррациональных).

Герман Минковский определил свою вопросительную функцию следующим рекурсивным образом: 

Первое уравнение привязывает функцию к началу координат, второе распространяет значение функции на отрезке [0,1] на всю числовую ось. Операция над двумя дробями  и , фигурирующая в левой части третьего равенства, называется медиантой и представляет собой одно из множества возможных средних значений для рациональных чисел.

Мне доводилось преподавать метематику средним школьникам. Ученики любопытны и ученики не любят, когда им указывают на ошибки. Это можно использовать. Если вместо того, чтобы сказать: "Неправильно. Садись.", воскликнуть: "Ну и ну, знаешь, что у тебя получилось!?", то ошибка превратится в небольшое приключение. Предположим, ученик пишет на доске: .

Понятно.. дробь опять превратилась в вектор! Не удивительно, это ведь куда проще, чем невесть откуда взявшиеся 5/6. К тому же перемножаем мы дроби как раз именно так: числитель — с числителем, знаменатель — с знаменателем. Вот бы и складывать так же!.. Давайте-ка спросим себя (и заодно, весь класс): "Получилась ли наша сумма больше обоих слагаемых?" Сравнивать дроби полезно, особенно, на числовой прямой. Рисуем и видим, что результат лежит где-то посередине между и . Вряд ли это сумма, скорее, какое-то среднее значение. Вот тут-то и можно воскликнуть: "А знаете, что мы получили вместо суммы? — Медианту!" Вот как она определяется для рациональным чисел: 

Медианта всегда лежит между операндами, для одинаковых чисел равна им обоим, ассоциативна, то есть, если часть усредняемых чисел заменить их средним, то общее среднее не изменится и т.д. Нормальное такое среднее значение. Но есть у этого среднего одна интересная особенность, если для двух дробей  и , выполняется равенство , их медиантой будет дробь с наименьшим возможным знаменателем, лежащая между ними. Наши школьные дроби  и  как раз такие: Между  и  не помещается ни одна дробь со знаменателем а дроби со знаменателями -- это и есть наши  и А вот — очень даже помещается! Это свойство медианты позволило построить одну из систем нумерации рациональных чисел: дерево Штерна-Броко, о котором писали даже на Хабре. Эта система оказалась полезной в дискретной математике, предлагая для любого числа элегантную кодировку его рационального приближения дробями с наименьшими знаменателями. Вообще говоря, она не столько полезна для самих вычислений, сколько для доказательства корректности алгоритмов вычислений с рациональными числами.

Собственно, одно из заданий на RosettaCode и состояло в том, чтобы написать программу на своём любимом языке, которая кодировала бы прямое и обратное преобразование Минковского. Мой любимы язык -- Haskell и я уже написал около сотни решений для RosettaCode на этом языке. Основной смысл сайта -- показать разнообразие языков через максимально естественные и идиоматичные решения различных задач, поэтому участники проекта стараются делать решения прозрачными и практичными, с одной стороны, "хвастаясь" возможностями языка, а с другой, избегая игры в code golf.

На момент написания этой статьи решения на всех языках, кроме Wolfram и Haskell были построчными "переводами" итеративного императивного кода, подобного тому, что приводится на странице Википедии. Это хороший надёжный и достаточно простой код, который можно перевести и на Haskell тоже. При внимательном рассмотрении и после погружения в тему, можно разглядеть среди множества буковок почему и как этот алгоритм работает. Императивное обратное преобразование, приведимое во всех решениях более длинное, но, в общем, тоже понятное. Однако, с некоторых пор компилятор -- уже не название человеческой профессии, а программа, так что просто переводить с одного языка на другой, не меняя парадигмы не интересно. Это стоит делать только если нативное решние уступает в эффективности или получается чересчур громоздким. В случае функции Минковского и обратной ей писать идиоматичное решение на Haskell имеет смысл, поскольку оно позволяет понять зачем в нашем мире существует и развивается этот чистый ленивый функциональный язык программирования.

Если записать определение функции Минковского, используя сивол   для взятия среднего арифметического двух чисел, то получится такое выражение:

Это значит, что она строит изоморфизм между двумя моноидами на множестве рациональных чисел с операциями медианты и взятия среднего арифметического. Любая солидная статья с ключевым словом "Haskell" обязана содержать слова с корнем "морфизм". У нас получается вполне себе настоящая статья! Этот изоморфизм позволяет нам определить как прямую, так и обратную функции Минковского самым естественным и даже нахальным образом, а именно, перечислить все рациональные числа и поставить каждому из низ в пару образ функции Минковского. Всего-то! 

Когда я грозился перечислить все рациональные числа, я не издевался, а имел в виду способ нумерации, о котором говорил выше, то есть, построение дерева Штерна-Броко. Для двоичного дерева, имеющего рекурсивный тип

дерево Штерна-Броко строится сверху вниз c использованием медианты в качестве операции для разделения интервала по следующему принципу:

Результат развёртки (анаморфизма) дерева с применением этого преобразования показан  в левой части рисунка:

Если мы подействуем на всё это дерево прямым гомомjрфизмом Минковского, то должны измениться не только узлы дерева, но и отношения, которыми они связаны, или, что тоже самое, операции, их порождающие, как показано в правой части русунка. Это значит, что правое дерево можно породить развёрткой с операцией взятия среднего.

Тут есть определённая тонкость с тем, как обращаться с представлением бесконечности, но о  ней мы поговорим чуть позже. А сейчас уже не терпится построить эти деревья.

Выращиваем изоморфные деревья

Выращивать бесконечные деревья на Haskell -- одно удовольствие! Он ленивый и декларативный, а значит определение дерева в программе будет буквально повторять математическое определение. Для работы с деревьями используем стандартный тип Data.Tree из пакета containers, входящего в базовый набор. Кроме того, нам понадобятся рациональные числа.

Определим для начала конструктор для интервальных деревьев с заданной операцией node, воспользовавшись библиотечной функцией развёртки для деревьев unfoldTree

Теперь мы готовы построить дерево Штерна-Броко:

При построении дерева мы использовали пары, а не рациональные числа для того, чтобы у нас была возможность оперировать с правой границей интервала --  значением . Так как сами границы в дерево не входят, результат уже не будет содержать чисел с нулём в знаменателе, поэтому мы можем перевести все пары в рациональные числа, воспользовавшись тем, что деревья являются функтором. 

Посмотрим на первые четыре слоя нашего дерева:

Это точно, оно -- дерево, методично перечисляющее все рациональные числа! Теперь построим изоморфное ему дерево,  воспользовавшись гомоморфизмом Минковского, то есть, просто заменив функция mediant на mean:

Оу, какая неприятность! Среднее арифметическое между любым числом и действительно, будет содержать ноль в знаменателе. Это особый случай и для того, чтобы его обойти, мы схитрим. Из второго уравнения в определении следует, что для целых чисел функция Минковского работает, как тождественное преобразование, то есть, не меняет это число. Это значит, что крайние правые значения в дереве Минковского будут совпадать с таковыми в дереве Штерна-Броко. Это значит, что в этом случае, мы воспользуемся медиантой, а не средним значением:

Вот они -- двоично-рациональные числа, соответствующие рациональным числам в дереве Штерна-Броко! Мы получили образ функции Минковского для множества положительных рациональных чисел. Круто, но как нам теперь построить саму фунцию Минковского, переводящую числа из одного дерева в другое?

В двоичном дереве можно отыскать любое конечное число. Наша функция могла бы искать заданное число в дереве Штерна-Броко и параллельно идти по дереву Минковского, совершая те же самые повороты в узлах. Обратная функция Минковского могла бы проделывать то же самое в обратном порядке: искать число в дереве образов и "по этому же адресу" отыскивать прообраз.

Бинарный поиск в двоичном дереве можно организовать, если оно сохраняет отношение порядка, определённое на множество его элементов. Нам во всех отношениях повезло! Штерн с Броко строят дерево сохраняя порядок рациональных чисел, потому что медианта -- это среднее значение, а функция Минковского сохраняет этот порядок (спасибо теореме Кантора об изоморфизме отношений порядка на всех счётных плотных неограниченных линейно-упорядоченных множествах). Значит можно организовывать бинарный поиск:

Вот, собственно, и всё:

λ> minkowskiQR (1/2) 1 % 2 λ> minkowskiQR (3/4) 7 % 8 λ> minkowskiQR (22/7) 193 % 64 λ> minkowskiQR 3.1415926 23433441659799429120906882473922936672367506843746678324850962561154188813677753172015 % 7770675568902916283677847627294075626569627356208558085007249638955617140820833992704 λ> invMinkowskiQR it 15707963 % 5000000

Похоже, работает! Но.. конечно же есть "но", куда же без них!

Первое "НО". В наших деревьях нет нуля и отрицательных значений. Это можно исправить програмно или системно. Програмно -- это поставив соответствующие условия и добавив логику, а системно -- расширив деревья на все множество рациональных чисел. Мне, как математику ближе системный подход. Напишем функцию, расширяющую числовое дерево своим "отражением" относительно нуля:

mirror :: Num a => Tree a -> Tree a mirror t = Node 0 [reflect (negate <$> t), t]   where     reflect (Node a [l,r]) = Node a [reflect r, reflect l]  minkowskiQM    = mirror sternBrocot ==> minkowski invMinkowskiQM = minkowski ==> sternBrocot

Второе "НО", посерьёзнее. Бинарный поиск в двоичном дереве штука хорошая, но он гарантирует результат только на ограниченных частично-упорядоченных множествах. Множество рациональных чисел не такое, на любом непустом интервале нет ни максимального, ни минимального элементов, и оно плотное, а значит, искать элемент на этом интервале можно бесконечно, постепенно приближаясь к искомому числу и забивая память всё большими и большими рациональными приближениями. И никакой экзотики или даже иррациональностей для этих неприятностей не нужно: достаточно попробовать поискать в дереве Минковского какое-нибудь число, которого там нет,  или , например. Наша функция молча уйдёт искать. И пожирать память.

Во-вторых, наше элегантное решение работает только на рациональных числах, а весь смысл работы Германа Минковского был в анализе кадратичных иррациональностей. Если мы станем искать в 

