Про вопросительный знак и корекурсию

В этой заметке я хочу поделиться решением одной любопытной задачи с замечательного сайта-хрестоматии RosettaCode. При этом будет немного математики, язык Haskell, ленивые вычисления, бесконечные деревья, доказательства корректности программ и другие плюшки.

Немного математики

Есть в теории чисел любопытная функция с не менее любопытными названием и обозначением: вопросительный знак Минковского (Fragenfunktion). С её помощью можно перенумеровать элементы расширения поля рациональных чисел квадратичными иррациональностями, то есть, корнями всех алгебраических уравнений второго порядка с рациональными коэффициентами. Не уверен, что большинство читателей впечатлит эта возможность, но функция такая есть и используется с 1904 года, когда её определил Герман Минковский в своём труде "Zur Geometrie der Zahlen" ("О теории чисел"). Потом детальный анализ этой функции был представлен в работе Арно Денджоя в 1938 году, а много позже независимо от Минковского обратную ей функцию определил знаменитый Джон Конвей, исследователь монструозных групп, создатель игры "Жизнь" и стрелочной нотации для очень-очень-преочень больших чисел. Не знаю уж чем руководствовался Герман Минковский, выбирая обозначение для своей функции, но Джон Конвей тоже не нашёл ничего лучше чем обозначить свою функцию квадратом. Итак, сегодня речь пойдёт о двух функциях:  и обратной ей  (и как только до изобретения LaTeX-а математики публиковали свои забавные символы?).

Вопросительный знак Минковского это монотонная вещественнозначная нечётная функция, заданная на всей числовой оси. В конечной форме она определяется довольно громоздко:

где -- это целые числа, появляющиеся при разложении числа в цепную дробь: 

Суммирование степеней двойки означает, что для эта функция превращает представление числа в виде цепной дроби в её двоично-рациональное представление:

Например, число 119/36 представляется в виде цепной дроби как функция Минковского преобразует его в такое двоично-рациональное число: (три нуля, три единицы, один ноль и две единицы). После интерпретации этого числа в  форме обычной дроби получим число . То есть,

Ну, и зачем понадобилась эта криптография? Для того, чтобы "разредить" плотное множество рациональных чисел и поместить в него квадратичные иррациональности. Все рациональные дроби имеют конечное представление в виде цепной дроби, а это значит, что функция Минковского отображает все рациональные числа в дроби со знаменателем -- степенью двойки. А как можно получить дробь с иным знаменателем? В двоично-рациональном представлении всем числам со знаменателями, не степенями двойки соответствуют бесконечные периодические дроби. Например, 

Прообразом такого числа должно быть число с бесконечной, но периодической цепной дробью. А это именно то свойство, что отличает квадратичные иррациональные числа от прочих иррациональных. Все такие числа имеют форму , где числа и -- рациональные. Например для приведённого примера прообраз функции Минковского:

Таким образом, функция Минковского помещает в "пространство" между прореженными рациональными числами все квадратичные иррациональности, причём она это делает очень аккуратно: монотонно, непрерывно и с сохранением порядка. Так что, хоть построение этой функции поначалу кажется искусственным, тем не менее, работает она  очень естественно (в смысле теории категорий). Она обладает рядом замечательных неочевидных симметрий, имеет фрактальный график и почти всюду нулевую производную (несмотря на непрерывность).

Собственно, одно из заданий на RosettaCode и состояло в том, чтобы написать программу на своём любимом языке, которая кодировала бы прямое и обратное преобразование Минковского. Мой любимы язык -- Haskell и я уже написал около сотни решений для RosettaCode на этом языке. Основной смысл сайта -- показать разнообразие языков через максимально естественные и идиоматичные решения различных задач, поэтому участники проекта стараются делать решения прозрачными и практичными, с одной стороны, "хвастаясь" возможностями языка, а с другой, избегая игры в code golf.

На момент написания этой статьи решения на всех языках, кроме Wolfram и Haskell были построчными "переводами" итеративного императивного кода, подобного тому, что приводится на странице Википедии. Это хороший надёжный и достаточно простой код, который можно перевести и на Haskell тоже. При внимательном рассмотрении и после погружения в тему, можно разглядеть среди множества буковок почему и как этот алгоритм работает. Императивное обратное преобразование, приведимое во всех решениях более длинное, но, в общем, тоже понятное. Однако, с некоторых пор компилятор -- уже не название человеческой профессии, а программа, так что просто переводить с одного языка на другой, не меняя парадигмы не интересно. Это стоит делать только если нативное решние уступает в эффективности или получается чересчур громоздким. В случае функции Минковского и обратной ей писать идиоматичное решение на Haskell имеет смысл, поскольку оно позволяет понять зачем  существует и развивается этот чистый ленивый функциональный язык программирования.

Выращиваем деревья

Арно Денджой выделил одно замечательное свойство функции Минковского: она является автоморфизмом двух моноидов на множестве рациональных чисел с операциями медианты и в среднее значение:

Небольшое отступление о медианте.

Мне доводилось преподавать метематику средним школьникам. Ученики любопытны и ученики не любят, когда им указывают на ошибки. Это можно использовать. Если вместо того, чтобы сказать: "Неправильно. Садись.", воскликнуть: "Ну и ну, знаешь, что у тебя получилось!?", то ошибка превратится в небольшое приключение. Поговорим об одной распространённой ошибке начинающего математика (класса четвёртого), имеющей, однако, смысл.

Предположим, ученик пишет на доске:

1/2 + 1/3 = (1+1)/(2+3) = 2/5

Понятно.. дробь опять превратилась в вектор! Не удивительно, это ведь куда проще, чем невесть откуда взявшиеся 5/6. К тому же перемножаем мы дроби как раз именно так: числитель — с числителем, знаменатель — с знаменателем. Вот бы и складывать так же!..
Давайте ка спросим себя (и заодно, весь класс): "Получилась ли наша сумма больше обоих слагаемых?" Сравнивать дроби полезно, особенно, на числовой прямой. Рисуем и видим, что результат 2/5 лежит где-то посередине между 1/3 и 1/2. Вряд ли это сумма, скорее, какое-то среднее значение. Вот тут-то и можно воскликнуть: "А знаете, что мы получили вместо суммы? — Медианту!"
Медианта для двух несократимых дробей 𝑎/𝑏 и 𝑐/𝑑, обозначаемая иногда 𝑎/𝑏 ⊕ 𝑐/𝑑 = (𝑎+𝑐)/(𝑏+𝑑), это одно из множества возможных средних значений для рациональных чисел. Она всегда лежит между операндами: 𝑝 ≤ 𝑝 ⊕ 𝑞 ≤ 𝑞, для одинаковых чисел равна им обоим: 𝑝 ⊕ 𝑝 = 𝑝, ассоциативна: 𝑝 ⊕ 𝑞 ⊕ 𝑟 ⊕ 𝑠 = 𝑝 ⊕ (𝑞 ⊕ 𝑟) ⊕ 𝑠, то есть, если часть усредняемых чисел заменить их средним, то общее среднее не изменится и т.д. Термин медианта был введён Александром Яковлевичем Хинчиным, но свойства такого оператора рассматривал ещё Коши. Они используются в теории чисел при анализе цепных дробей, в математической статистике и в математическом анализе.
Но есть у этого среднего одна интересная особенность, если для двух дробей 𝑎/𝑏 и 𝑐/𝑑, выполняется равенство |𝑎𝑑 – 𝑏𝑐| = 1, их медиантой будет дробь с наименьшим возможным знаменателем, лежащая между ними. Давайте проверим, наши дроби 1/3 и 1/2 как раз такие: |2·1 – 3·1| = 1. Между 1/3 и 1/2 не помещается ни одна дробь со знаменателем 4, а дроби со знаменателями 6 это и есть наши 1/3 = 2/6 и 1/2 = 3/6. А вот 1/3 ⊕ 1/2 = 2/5 — очень даже помещается! Между медиантой и крайними дробями помещаются их медианты: 1/3 ⊕ 2/5 = 3/8, 2/5 ⊕ 1/2 = 3/7 можете проверить, и убедиться, что они тоже будут дробями с наименьшими знаменателями на этих отрезках.
Это свойство медианты позволило построить одну из систем нумерации рациональных чисел: дерево Штерна-Броко. На иллюстрациях приведены три способа его изображения. Эта система оказалась полезной в дискретной математике, предлагая для любого числа элегантную кодировку его рационального приближения дробями с наименьшими знаменателями. Она не столько полезна для самих вычислений, сколько для доказательства корректности алгоритмов вычислений с рациональными числами.
3
	x = [a_0;a_1, a_2, a_3,a_4...] = a_0 + \overbrace{\underbrace{0.0...0}_{a_1}}^{нули}\overbrace{\underbrace{11..11}_{a_2}}^{единицы}\overbrace{\underbrace{0...0}_{a_3}}^{нулb}\overbrace{\underbrace{11..11}_{a_4}}^{единицы}...
	
?^{-1}\left(\frac{2}{7}\right) = ?^{-1}\left(0.110110110..._{(2)}\right) = [0;1,2,1,2,1...] = [0;(1,2)] = \frac{\sqrt3 - 1}{2}
